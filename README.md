<h1>Односвязный стек</h1>
Давайте реализуем стек на основе односвязного стека. Значения стека будем хранить в обёртке, где помимо значения будет указатель на ниже в стеке элемент, в самом же стеке будем хранить указатель на самый верхний элемент:
```
Node:
  value - значение в обёртке
  prev - элемент, ниже в стеке

Stack:
  head - указатель на обёртку с элементом, который надо вынуть следующим
```
Давайте реализуем две основные для стека операции. Для push создадим обёртку для нового значения, на который теперь будет указывать голова стека, а на старую голову будет указывать указатель на предыдущий элемент в обёртке. Для pop вынем значение из обёртки, на которую указывает голова стека, после чего передвиним голову стека на ту обёртку, на которую указывал указатель на предыдущий элемент в голове стека.
```
Stack:
  ...

  push(value):
    if head пустая
      head = Node(value=value, prev=пусто)
    else
      node = Node(value=value, prev=head)
      head = node
  
  def pop(self):
    if head пустая
      return нет элементов!
    else
      value = head.value
      head = head.prev
      return value
```
Теперь давайте добавим метод вывода стека на экран:
```
Stack:
  ...

  printme():
    if head пустая
      напечатаем "EMPTY"
    else
      node = head
      while node не пустой
        напечатаем node.value
        if у node есть предыдущий
          напечатаем " -> "
        node = node.prev
```
<h2>Дополнительно: reverse</h2>
Можно сделать ещё один метод: reverse(), который бы возвращал новый стек, в котором те же элементы, но в другом порядке. Это сделаем рекурсивно, напишем вспомогательную функцию, которая будет принимать односвязный список и будет возвращать два значения: голову и хвост нового списка, который является ревёрсом (т.е. в обратном порядке) исходного списка. Для языков, где нельзя вернуть несколько значений, заведите, например, вспомогательный класс, объект которого вы заполните возвращаемыми значениями и вернёте как результат функции.
```
Stack:
  ...

  reverse():
    if head пустая: return Stack()

    reversed_head(node):
      new_node = Node(value=node.value)
      if node.prev пустая:
        return (new_node, new_node)
      else:
        head, tail = reversed_head(node.prev)
        tail.prev = new_node
        return (head, new_node)
    reversed_stack = Stack()
    new_head, new_tail = reversed_head(self.head)
    reversed_stack.head = new_head
    return reversed_stack
```

